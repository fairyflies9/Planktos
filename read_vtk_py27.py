#! /usr/bin/env python2
'''
Read in VTK data using Python 2.5+ and pickle. This serves as a workaround
when VTK does not work in Python 3. The pickled data can then be loaded by
the environment class in framework.py.
'''

import os
import pickle
import numpy as np
import data_IO

def read_IB2d_vtk_data(pathViz, dt, print_dump, d_start=0, d_finish=None):
    '''Reads in vtk flow data generated by IB2d and pickles.

    IB2d is an Immersed Boundary (IB) code for solving fully coupled
    fluid-structure interaction models in Python and MATLAB. The code is 
    hosted at https://github.com/nickabattista/IB2d

    Arguments:
        - pathViz: full path to viz_IB2d folder
        - dt: dt in input2d parameter file
        - print_dump: print_dump in input2d parameter file
        - d_start: number of first vtk dump to read in
        - d_finish: number of last vtk dump to read in, or None to read to end
    '''

    ##### Parse parameters and read in data #####

    pathViz = os.path.normpath(pathViz)
    if pathViz[-1] == os.sep:
        pathViz = pathViz[:-1]
    if os.path.basename(pathViz) != 'viz_IB2d':
        pathViz = os.path.join(pathViz,'viz_IB2d')

    if d_finish is None:
        #infer d_finish
        file_names = [filen for subdir, dirs, filen in os.walk(pathViz)]
        uX_nums = sorted([int(f[3:7]) for f in file_names if f[:3] == 'uX.'])
        d_finish = uX_nums[-1]

    X_vel = []
    Y_vel = []

    for n in range(d_start, d_finish+1):
        # Points to desired data viz_IB2d data file
        if n < 10:
            numSim = '000'+str(n)
        elif n < 100:
            numSim = '00'+str(n)
        elif n < 1000:
            numSim = '0'+str(n)
        else:
            numSim = str(n)

        # Imports (x,y) grid values and ALL Eulerian Data %
        #                      DEFINITIONS
        #          x: x-grid                y: y-grid
        #       Omega: vorticity           P: pressure
        #    uMag: mag. of velocity
        #    uX: mag. of x-Velocity   uY: mag. of y-Velocity
        #    U: x-directed velocity   V: y-directed velocity
        #    Fx: x-directed Force     Fy: y-directed Force
        #
        #  Note: U(j,i): j-corresponds to y-index, i to the x-index
        #
        # read in x-directed Velocity Magnitude #
        strChoice = 'uX'; xy = True
        uX,x,y = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
                                                        strChoice,xy)
        X_vel.append(uX.T) # (y,x) -> (x,y) coordinates

        # read in y-directed Velocity Magnitude #
        strChoice = 'uY'
        uY = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
                                                    strChoice)
        Y_vel.append(uY.T) # (y,x) -> (x,y) coordinates

        # read in Vorticity #
        # strChoice = 'Omega'; first = 0
        # Omega = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                               strChoice,first)
        # read in Pressure #
        # strChoice = 'P'; first = 0
        # P = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                           strChoice,first)
        # read in Velocity Magnitude #
        # strChoice = 'uMag'; first = 0
        # uMag = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                              strChoice,first)
        # read in x-directed Forces #
        # strChoice = 'Fx'; first = 0
        # Fx = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                            strChoice,first)
        # read in y-directed Forces #
        # strChoice = 'Fy'; first = 0
        # Fy = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                            strChoice,first)

    ### Save data ###
    flow = [np.array(X_vel).squeeze(), np.array(Y_vel).squeeze()]
    flow_file = open('flow.pickle','wb')
    pickle.dump(flow,flow_file)
    flow_file.close()
    
    if d_start != d_finish:
        flow_times = np.arange(d_start,d_finish+1)*print_dump*dt
    else:
        flow_times = None
    flow_times_file = open('flow_times.pickle','wb')
    pickle.dump(flow_times,flow_times_file)
    flow_times_file.close()
    
    # shift domain to quadrant 1
    flow_points = (x-x[0], y-y[0])
    flow_points_file = open('flow_points.pickle','wb')
    pickle.dump(flow_points,flow_points_file)
    flow_points_file.close()



def read_IBAMR3d_vtk_data(path, start=None, finish=None):
    '''Reads in vtk flow data generated by VisIt from IBAMR and pickles. 
    Assumes that the vtk filenames are IBAMR_db_###.vtk 
    where ### is the dump number, as automatically done
    with read_IBAMR3d_py27.py. Also assumes that the mesh is the same
    for each vtk.

    Imported times will be translated backward so that the first time loaded
    corresponds to an agent environment time of 0.0.

    Arguments:
        path: path to vtk data
        start: vtk file number to start with. If None, start at first one.
        finish: vtk file number to end with. If None, end with last one.
    '''

    assert os.path.exists(path), "Path {} not found!".format(path)
    file_names = [filen for subdir, dirs, filen in os.walk(path) if 
                  filen[:9] == 'IBAMR_db_']
    file_nums = sorted([int(f[9:12]) for f in file_names])
    if start is None:
        start = file_nums[0]
    else:
        start = int(start)
        assert start in file_nums, "Start number not found!"
    if finish is None:
        finish = file_nums[-1]
    else:
        finish = int(finish)
        assert finish in file_nums, "Finish number not found!"

    ### Gather data ###
    flow = [[], [], []]
    flow_times = []

    for n in range(start, finish+1):
        if n < 10:
            num = '00'+str(n)
        elif n < 100:
            num = '0'+str(n)
        else:
            num = str(n)
        this_file = path / ('IBAMR_db_'+num+'.vtk')
        data, mesh, time = data_IO.read_vtk_Rectilinear_Grid_Vector(str(this_file))
        for dim in range(3):
            flow[dim].append(data[dim].T) # (z,y,x) -> (x,y,z) coordinates
        flow_times.append(time)

    ### Save data ###
    flow = [np.array(flow[0]).squeeze(), np.array(flow[1]).squeeze(),
            np.array(flow[2]).squeeze()]
    flow_file = open('flow.pickle','wb')
    pickle.dump(flow,flow_file)
    flow_file.close()
    # parse time information
    if None not in flow_times and len(flow_times) > 1:
        # shift time so that the first time is 0.
        flow_times = np.array(flow_times) - min(flow_times)
    elif None in flow_times and len(flow_times) > 1:
        # could not parse time information
        warnings.warn("Could not retrieve time information from at least"+
                        " one vtk file. Assuming unit time-steps...", UserWarning)
        flow_times = np.arange(len(flow_times))
    else:
        flow_times = None
    flow_times_file = open('flow_times.pickle','wb')
    pickle.dump(flow_times,flow_times_file)
    flow_times_file.close()
    # shift domain to quadrant 1
    flow_points = (mesh[0]-mesh[0][0], mesh[1]-mesh[1][0],
                   mesh[2]-mesh[2][0])
    flow_points_file = open('flow_points.pickle','wb')
    pickle.dump(flow_points,flow_points_file)
    flow_points_file.close()
    # record the original lower left corner (can be useful for later imports)
    fluid_domain_LLC = (mesh[0][0], mesh[1][0], mesh[2][0])
    flow_LLC_file = open('flow_LLC.pickle','wb')
    pickle.dump(fluid_domain_LLC,flow_LLC_file)
    flow_LLC_file.close()
