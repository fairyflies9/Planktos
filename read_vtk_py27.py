#! /usr/bin/env python2
'''
Read in VTK data using Python 2.5+ and save with numpy. This serves as a workaround
when VTK does not work in Python 3 or in a particular OS. The npy data can then be loaded by
the environment class in framework.py.
'''

import os
import numpy as np
import data_IO
import warnings

def read_IB2d_vtk_data(pathViz, dt, print_dump, d_start=0, d_finish=None,
                       prefix=''):
    '''Reads in vtk flow data generated by IB2d and saves as npy.

    IB2d is an Immersed Boundary (IB) code for solving fully coupled
    fluid-structure interaction models in Python and MATLAB. The code is 
    hosted at https://github.com/nickabattista/IB2d

    Arguments:
        pathViz: full path to viz_IB2d folder
        dt: dt in input2d parameter file
        print_dump: print_dump in input2d parameter file
        d_start: number of first vtk dump to read in
        d_finish: number of last vtk dump to read in, or None to read to end
        prefix: prefix to add to each default file name
    '''

    ##### Parse parameters and read in data #####

    pathViz = os.path.normpath(pathViz)
    if pathViz[-1] == os.sep:
        pathViz = pathViz[:-1]
    if os.path.basename(pathViz) != 'viz_IB2d':
        pathViz = os.path.join(pathViz,'viz_IB2d')

    if d_finish is None:
        #infer d_finish
        file_names = [filen for subdir, dirs, filen in os.walk(pathViz)]
        uX_nums = sorted([int(f[3:7]) for f in file_names if f[:3] == 'uX.'])
        d_finish = uX_nums[-1]

    X_vel = []
    Y_vel = []

    for n in range(d_start, d_finish+1):
        # Points to desired data viz_IB2d data file
        if n < 10:
            numSim = '000'+str(n)
        elif n < 100:
            numSim = '00'+str(n)
        elif n < 1000:
            numSim = '0'+str(n)
        else:
            numSim = str(n)

        # Imports (x,y) grid values and ALL Eulerian Data %
        #                      DEFINITIONS
        #          x: x-grid                y: y-grid
        #       Omega: vorticity           P: pressure
        #    uMag: mag. of velocity
        #    uX: mag. of x-Velocity   uY: mag. of y-Velocity
        #    U: x-directed velocity   V: y-directed velocity
        #    Fx: x-directed Force     Fy: y-directed Force
        #
        #  Note: U(j,i): j-corresponds to y-index, i to the x-index
        #
        # read in x-directed Velocity Magnitude #
        strChoice = 'uX'; xy = True
        uX,x,y = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
                                                        strChoice,xy)
        X_vel.append(uX.T) # (y,x) -> (x,y) coordinates

        # read in y-directed Velocity Magnitude #
        strChoice = 'uY'
        uY = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
                                                    strChoice)
        Y_vel.append(uY.T) # (y,x) -> (x,y) coordinates

        # read in Vorticity #
        # strChoice = 'Omega'; first = 0
        # Omega = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                               strChoice,first)
        # read in Pressure #
        # strChoice = 'P'; first = 0
        # P = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                           strChoice,first)
        # read in Velocity Magnitude #
        # strChoice = 'uMag'; first = 0
        # uMag = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                              strChoice,first)
        # read in x-directed Forces #
        # strChoice = 'Fx'; first = 0
        # Fx = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                            strChoice,first)
        # read in y-directed Forces #
        # strChoice = 'Fy'; first = 0
        # Fy = data_IO.read_2DEulerian_Data_From_vtk(pathViz,numSim,
        #                                            strChoice,first)

    ### Save data ###
    flow = [np.array(X_vel).squeeze(), np.array(Y_vel).squeeze()]
    np.savez(prefix+'flow', xflow=flow[0], yflow=flow[1], allow_pickle=False)
    
    if d_start != d_finish:
        flow_times = np.arange(d_start,d_finish+1)*print_dump*dt
    else:
        flow_times = np.array(np.nan)
    np.save(prefix+'flow_times', flow_times, allow_pickle=False)
    
    # shift domain to quadrant 1
    flow_points = (x-x[0], y-y[0])
    np.savez(prefix+'flow_points', xpoints=flow_points[0], ypoints=flow_points[1], 
             allow_pickle=False)



def read_IBAMR3d_vtk_data(path, start=None, finish=None, prefix=''):
    '''Reads in vtk flow data generated by VisIt from IBAMR and saves as npy. 
    Assumes that the vtk filenames are IBAMR_db_###.vtk 
    where ### is the dump number, as automatically done
    with read_IBAMR3d_py27.py. Also assumes that the mesh is the same
    for each vtk.

    Imported times will be translated backward so that the first time loaded
    corresponds to an agent environment time of 0.0.

    Arguments:
        path: path to vtk data
        start: vtk file number to start with. If None, start at first one.
        finish: vtk file number to end with. If None, end with last one.
        prefix: prefix to add to each default file name
    '''

    assert os.path.exists(path), "Path {} not found!".format(path)
    file_names = []
    for dirpath, dirnames, filenames in os.walk(path):
        file_names += [f for f in filenames if f[:9] == 'IBAMR_db_']
    file_nums = sorted([int(f[9:12]) for f in file_names])
    if start is None:
        start = file_nums[0]
    else:
        start = int(start)
        assert start in file_nums, "Start number not found!"
    if finish is None:
        finish = file_nums[-1]
    else:
        finish = int(finish)
        assert finish in file_nums, "Finish number not found!"

    ### Gather data ###
    flow = [[], [], []]
    flow_times = []

    for n in range(start, finish+1):
        if n < 10:
            num = '00'+str(n)
        elif n < 100:
            num = '0'+str(n)
        else:
            num = str(n)
        this_file = os.path.join(path,'IBAMR_db_'+num+'.vtk')
        data, mesh, time = data_IO.read_vtk_Rectilinear_Grid_Vector(this_file)
        for dim in range(3):
            flow[dim].append(data[dim].T) # (z,y,x) -> (x,y,z) coordinates
        flow_times.append(time)

    ### Save data ###
    flow = [np.array(flow[0]).squeeze(), np.array(flow[1]).squeeze(),
            np.array(flow[2]).squeeze()]
    np.savez(prefix+'flow', xflow=flow[0], yflow=flow[1], zflow=flow[2], allow_pickle=False)
    # parse time information
    if None not in flow_times and len(flow_times) > 1:
        # shift time so that the first time is 0.
        flow_times = np.array(flow_times) - min(flow_times)
    elif None in flow_times and len(flow_times) > 1:
        # could not parse time information
        warnings.warn("Could not retrieve time information from at least"+
                        " one vtk file. Assuming unit time-steps...", UserWarning)
        flow_times = np.arange(len(flow_times))
    else:
        flow_times = np.array(np.nan)
    np.save(prefix+'flow_times', flow_times, allow_pickle=False)
    # shift domain to quadrant 1
    flow_points = (mesh[0]-mesh[0][0], mesh[1]-mesh[1][0],
                   mesh[2]-mesh[2][0])
    np.savez(prefix+'flow_points', xpoints=flow_points[0], ypoints=flow_points[1],
             zpoints=flow_points[2], allow_pickle=False)
    # record the original lower left corner (can be useful for later imports)
    fluid_domain_LLC = np.array((mesh[0][0], mesh[1][0], mesh[2][0]))
    np.save(prefix+'flow_LLC', fluid_domain_LLC, allow_pickle=False)
